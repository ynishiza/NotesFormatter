{\rtf1\ansi\ansicpg1252\cocoartf2639
\cocoatextscaling0\cocoaplatform0{\fonttbl\f0\fnil\fcharset0 HelveticaNeue;\f1\fnil\fcharset0 Monaco;\f2\fnil\fcharset0 HelveticaNeue-Bold;
\f3\fnil\fcharset0 Menlo-Regular;}
{\colortbl;\red255\green255\blue255;\red0\green0\blue0;\red0\green0\blue233;\red38\green38\blue38;
\red226\green226\blue226;\red255\green255\blue255;\red226\green226\blue226;\red226\green226\blue226;}
{\*\expandedcolortbl;;\cssrgb\c0\c0\c0;\cssrgb\c0\c0\c93333;\cssrgb\c20000\c20000\c20000;
\cssrgb\c90980\c90980\c90980;\csgray\c100000;\csgenericrgb\c88766\c88766\c88766;\csgenericrgb\c88766\c88766\c88766;}
\deftab720
\pard\pardeftab720\partightenfactor0

\f0\fs28 \cf2 \expnd0\expndtw0\kerning0
hspec:\'a0{\field{\*\fldinst{HYPERLINK "https://hackage.haskell.org/package/hspec"}}{\fldrslt \cf3 \ul \ulc3 https://hackage.haskell.org/package/hspec}}\
hspec-expectations:\'a0{\field{\*\fldinst{HYPERLINK "https://hackage.haskell.org/package/hspec-expectations"}}{\fldrslt \cf3 \ul \ulc3 https://hackage.haskell.org/package/hspec-expectations}}\
hspec manual:\'a0{\field{\*\fldinst{HYPERLINK "https://hspec.github.io/"}}{\fldrslt \cf3 \ul \ulc3 https://hspec.github.io/}}\
\
\
\pard\pardeftab720\partightenfactor0

\f1 \cf4 \cb5  \
- Test.Hspec\
hspec :: Spec -> IO ()\
it :: (HasCallStack, Example a) => String -> a -> SpecWith (Arg a)\
xit :: (HasCallStack, Example a) => String -> a -> SpecWith (Arg a)\'a0\'a0 \'a0\'a0 \'a0\'a0-- ignore\
fit :: (HasCallStack, Example a) => String -> a -> SpecWith (Arg a)\'a0\'a0 \'a0\'a0 \'a0\'a0-- focus i.e. opposite of ignore\
describe :: HasCallStack => String -> SpecWith a -> SpecWith a\
xdescribe :: HasCallStack => String -> SpecWith a -> SpecWith a\
fdescribe :: HasCallStack => String -> SpecWith a -> SpecWith a\
focus :: SpecWith a -> SpecWith a\
pending :: HasCallStack => Expectation\
pendingWith :: HasCallStack => String -> Expectation\
example :: Expectation -> Expectation\
parallel :: SpecWith a -> SpecWith a\
ignoreSubject :: SpecWith () -> SpecWith a\
mapSubject :: (b -> a) -> SpecWith a -> SpecWith b\
\
\
-- Hooks\
type ActionWith a = a -> IO ()\
before :: IO a -> SpecWith a -> Spec\
before_ :: IO () -> SpecWith a -> SpecWith a\
beforeWith :: (b -> IO a) -> SpecWith a -> SpecWith b\
beforeAll :: HasCallStack => IO a -> SpecWith a -> Spec\
beforeAll_ :: HasCallStack => IO a -> SpecWith a -> SpecWith a\
beforeAllWith :: HasCallStack => (b -> IO a) -> SpecWith a -> SpecWith b\
after :: ActionWith a -> SpecWith a -> SpecWith a\
after_ :: IO () -> SpecWith a -> SpecWith a\
afterAll :: HasCallStack => ActionWith a -> SpecWith a -> SpecWith a\
afterAll_ :: HasCallStack => IO () -> SpecWith a -> SpecWith a\
around :: (ActionWith a -> IO ()) -> SpecWith a -> Spec\
around_ :: IO () -> SpecWith a -> SpecWith a\
\'85\'a0\
\
newtype SpecM a r = \'85 \
type SpecWith a = SpecM a ()\
type Spec = SpecWith ()\
\
type family Arg e\
type Arg Property = ()\
type Arg Expectation = ()\
\
type Arg (a -> Property) = a\
\'85 \
\
\
class Example e where\
 type Arg e\
 evaluateExample :: \'85 \
instance Example Property\
instance Example Expectation\
\'85 \
\
\pard\pardeftab720\partightenfactor0

\f0 \cf2 \cb1 \
Expectations\
\pard\pardeftab720\partightenfactor0

\f1 \cf4 \cb5  \
-- Test.Hspec.Expectations\
type Expectations = IO ()\
expectationFailure :: HasCallStack => String -> Expectation\
shouldBe :: (HasCallStack, Show a, Eq a) => a -> a -> Expectation\
shouldNotBe :: (HasCallStack, Show a, Eq a) => a -> a -> Expectation\
shouldSatisfy :: (HasCallStack, Show a) => a -> (a -> Bool) -> Expectation\
shouldNotSatisfy :: (HasCallStack, Show a) => a -> (a -> Bool) -> Expectation\
\'85 \
\
type Selector = a -> Bool\
shouldThrow :: (HasCallStack, Exception e) => IO a -> Selector e -> Expectation\
anyException :: Selector Exception\
anyErroCall :: Selector ErrorCall\
anyIOError :: Selector IOError\
\'85 \
\
\pard\pardeftab720\partightenfactor0

\f0 \cf2 \cb1 \
\
Types /classes\
- type
\f2\b \'a0Spec = SpecWith ()
\f0\b0 : a single test or a group of tests\
- type
\f2\b \'a0SpecWith a
\f0\b0 : a single test or a group of tests with 
\f2\b test params
\f0\b0  aka arguments a\
\'a0 i.e. a test with 
\f2\b setup
\f0\b0  parameters, created by setup hooks\
\'a0 e.g. by the 
\f2\b before
\f0\b0  hook\
- 
\f2\b class Example
\f0\b0 : the content of a single test.\
\'a0 e.g. the 
\f2\b Exception type = Assertion = IO ()\'a0
\f0\b0 representing an assertion.\
\'a0 e.g. the 
\f2\b Property type
\f0\b0  representing a single property test\
\
e.g. relationship of types\
\pard\pardeftab720\partightenfactor0

\f1 \cf4 \cb5  \
describe "My tests" $ do\'a0\'a0 \'a0\'a0\'a0 \'a0\'a0\'a0 \'a0\'a0\'a0 \'a0\'a0\'a0 \'a0\'a0\'a0 \'a0\'a0 \'a0\'a0-- describe :: String -> Spec\
\'a0 -- tests with no args\
\'a0\'a0describe "Basic" $ do\'a0\'a0 \'a0\'a0\'a0 \'a0\'a0\'a0 \'a0\'a0\'a0 \'a0\'a0\'a0 \'a0\'a0 \'a0 \'a0 \'a0 \'a0-- describe :: String -> Spec\
\'a0\'a0\'a0\'a0it "1 == 1" $\'a0\'a0 \'a0\'a0\'a0 \'a0\'a0\'a0 \'a0\'a0\'a0 \'a0\'a0\'a0 \'a0\'a0\'a0 \'a0\'a0\'a0 \'a0\'a0\'a0 \'a0\'a0 \'a0-- it :: String -> Expectation -> Spec\
\'a0\'a0\'a0\'a0\'a0\'a01 `shouldBe` 1\
\
\'a0 -- tests with args\
\'a0 testSetup `before` $ \'a0 \'a0 \'a0 \'a0 \'a0 \'a0 \'a0 \'a0 \'a0 \'a0 \'a0 \'a0 \'a0 \'a0 \'a0 \'a0-- before :: IO Int -> SpecWith Int -> Spec\
\'a0 \'a0 testCleanup `after` $ \'a0 \'a0 \'a0 \'a0 \'a0 \'a0 \'a0 \'a0 \'a0 \'a0 \'a0 \'a0 \'a0 \'a0 -- after :: ActionWith Int -> SpecWith Int -> SpecWith Int\
\'a0\'a0\'a0\'a0\'a0\'a0describe "Tests with test args" $ do\'a0\'a0 \'a0\'a0\'a0 \'a0\'a0\'a0-- describe :: String -> SpecWith Int -> SpecWith Int\
\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0it "is not zero" $ \\v -> do\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0-- it :: String -> (Int -> Expectation) -> SpecWith (Arg (Int -> Expectation))\
\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0v `shouldNotBe` 0\'a0\'a0 \'a0\'a0\'a0 \'a0\'a0\'a0 \'a0\'a0\'a0 \'a0\'a0\'a0 \'a0\'a0 \'a0 \'a0\
\'a0\'a0where\
\'a0\'a0\'a0\'a0testSetup :: IO Int\
\'a0\'a0\'a0\'a0testSetup = getStdRandom uniform\
\'a0\'a0\'a0\'a0testCleanup v = putStrLn $ "tested with=" ++ show v\
\
\pard\pardeftab720\partightenfactor0

\f0 \cf2 \cb1 \
\
\
\pard\pardeftab720\partightenfactor0
\cf2 \ul \ulc2 CLI\ulnone \
Ref:\'a0{\field{\*\fldinst{HYPERLINK "https://hspec.github.io/options.html"}}{\fldrslt \cf3 \ul \ulc3 https://hspec.github.io/options.html}}\
\
\pard\pardeftab720\partightenfactor0

\f1 \cf4 # Running
\f0 \cf2 \

\f1 \cf4 #
\f0 \cf2 \

\f1 \cf4 # With bin
\f0 \cf2 \

\f1 \cf4 $ ./test\'a0--randomize\'a0--fail-fast
\f0 \cf2 \
\

\f1 \cf4 # With Stack
\f0 \cf2 \

\f1 \cf4 $ stack test <target>\'a0--test-arguments="--randomize\'a0--fail-fast"
\f0 \cf2 \
\
\

\f1 \cf4 # Basic
\f0 \cf2 \

\f1 \cf4 $ <CLI> --help
\f0 \cf2 \

\f1 \cf4 $ <CLI>\'a0--randomize\'a0\'85\'a0
\f0 \cf2 \

\f1 \cf4 $ <CLI>\'a0--dry-run \'85\'a0
\f0 \cf2 \

\f1 \cf4 $ <CLI>\'a0--fail-fast \'85\'a0
\f0 \cf2 \
\

\f1 \cf4 $ <CLI>\'a0--match\'a0"hello"
\f0 \cf2 \

\f1 \cf4 $ <CLI> -m "hello"
\f0 \cf2 \

\f1 \cf4 $ <CLI> -m\'a0"*"\'a0\'a0 \'a0\'a0\'a0 \'a0\'a0 \'a0 # NO wildcard?
\f0 \cf2 \

\f1 \cf4 $ <CLI> -m\'a0"*"\'a0\'a0 \'a0\'a0\'a0 \'a0\'a0 \'a0 # NO regex?
\f0 \cf2 \
\
\
\
\pard\pardeftab720\partightenfactor0
\cf2 \ul Usage: run tests with arguments in GHCI\'a0\ulnone \
Passing options:\'a0{\field{\*\fldinst{HYPERLINK "https://hspec.github.io/options.html"}}{\fldrslt \cf3 \ul \ulc3 https://hspec.github.io/options.html}}\
Running individual tests:\'a0{\field{\*\fldinst{HYPERLINK "https://hspec.github.io/match.html"}}{\fldrslt \cf3 \ul \ulc3 https://hspec.github.io/match.html}}\
Use 
\f2\b :main
\f0\b0  command\
\
e.g. in Stack\
\pard\pardeftab720\partightenfactor0

\f1 \cf4 \cb5  \
--\'a0./test/Spec.hs\
import Hspec\
\
main = describe\'a0"My test" $ do\
\'a0\'a0\'85\'a0\
\
\pard\pardeftab720\partightenfactor0

\f0 \cf2 \cb1 \
Run in GHCI\
\pard\pardeftab720\partightenfactor0

\f1 \cf4 \cb5  \
$ stack ghci MyProject:test:main-test\
\
ghci> :main\'a0--match="Test1"\
\
\pard\pardeftab720\partightenfactor0

\f0 \cf2 \cb1 \
Run with stack\
\pard\pardeftab720\partightenfactor0

\f1 \cf4 \cb5  \
$ stack test --test-arguments="--match='Test1'" MyProject:test:main-test\
\
\pard\pardeftab720\partightenfactor0

\f0 \cf2 \cb1 \
\
\
\ul Usage: Basic setup\ulnone \
Ref:\'a0{\field{\*\fldinst{HYPERLINK "https://hspec.github.io/writing-specs.html"}}{\fldrslt \cf3 \ul \ulc3 https://hspec.github.io/writing-specs.html}}\
\
e.g.\'a0\
\pard\pardeftab720\partightenfactor0

\f1 \cf4 \cb5  \
import System.Random\
import Test.Hspec\
\
main = hspec mainSpecs\
\
mainSpecs :: SpecWith ()\
mainSpecs =\
\'a0\'a0-- e.g. hooks\
\'a0\'a0beforeAll_ onBefore $\
\'a0\'a0\'a0\'a0afterAll_ onAfter $\
\'a0\'a0\'a0\'a0\'a0\'a0before_ onBeforeEach $\
\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0after_ onAfterEach specs1\
\'a0\'a0where\
\'a0\'a0\'a0\'a0onBefore = putStrLn "Before"\
\'a0\'a0\'a0\'a0onAfter = putStrLn "After"\
\'a0\'a0\'a0\'a0onBeforeEach = putStrLn "BeforeEach"\
\'a0\'a0\'a0\'a0onAfterEach = putStrLn "AfterEach"\
\
randomInt :: IO Int\
randomInt = getStdRandom uniform\
\
specs1 :: SpecWith ()\
specs1 = describe "My tests" $ do\
\'a0\'a0\'a0-- e.g. basic test\
\'a0\'a0describe "Basic" $ do\
\'a0\'a0\'a0\'a0it "1 == 1" $\
\'a0\'a0\'a0\'a0\'a0\'a01 `shouldBe` 1\
\'a0\'a0\'a0\'a0it "1 /= 2" $\
\'a0\'a0\'a0\'a0\'a0\'a01 `shouldNotBe` 2\
\
\'a0\'a0-- e.g. test using IO\
\'a0\'a0describe "IO" $ do\
\'a0\'a0\'a0\'a0it "use IO" $ do\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0-- can use IO since Expectation is just IO ()\
\'a0\'a0\'a0\'a0\'a0\'a0putStrLn "Enter 1"\
\'a0\'a0\'a0\'a0\'a0\'a0z <- getLine\
\'a0\'a0\'a0\'a0\'a0\'a0z `shouldBe` "1"\
\'a0\'a0\'a0\'a0it "Random" $ do\
\'a0\'a0\'a0\'a0\'a0\'a0x <- randomInt\
\'a0\'a0\'a0\'a0\'a0\'a0y <- randomInt\
\'a0\'a0\'a0\'a0\'a0\'a0x `shouldNotBe` y\
\
\'a0\'a0-- e.g. pending tests\
\'a0\'a0describe "Pending" $ do\
\'a0\'a0\'a0\'a0it "TODO 1" $ do\
\'a0\'a0\'a0\'a0\'a0\'a0pending\
\'a0\'a0\'a0\'a0it "TODO 2" $ do\
\'a0\'a0\'a0\'a0\'a0\'a0pendingWith "TODO"\
\
\'a0\'a0-- e.g. tests with setup values\
\'a0\'a0before testSetup $\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0-- before: create test params\
\'a0\'a0\'a0\'a0after testCleanup $\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0-- after: cleanup test params\
\'a0\'a0\'a0\'a0\'a0\'a0describe "Tests with test args" $ do\
\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0it "is not zero" $ \\v -> do\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0-- test with params\
\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0v `shouldNotBe` 0\
\'a0\'a0where\
\'a0\'a0\'a0\'a0testSetup :: IO Int\
\'a0\'a0\'a0\'a0testSetup = getStdRandom uniform\
\'a0\'a0\'a0\'a0testCleanup v = putStrLn $ "tested with=" ++ show v\
\
\pard\pardeftab720\partightenfactor0

\f0 \cf2 \cb1 \
Output\
\pard\pardeftab720\partightenfactor0

\f1 \cf4 \cb5  \
$ ./main\
My tests\
\'a0\'a0Basic\
Before\
BeforeEach\
AfterEach\
\'a0\'a0\'a0\'a01 == 1 [
\f3 \uc0\u10004 
\f1 ]\
BeforeEach\
AfterEach\
\'a0\'a0\'a0\'a01 /= 2 [
\f3 \uc0\u10004 
\f1 ]\
\'a0\'a0IO\
BeforeEach\
Enter 1\
1\
AfterEach\
\'a0\'a0\'a0\'a0use IO [
\f3 \uc0\u10004 
\f1 ]\
BeforeEach\
AfterEach\
\'a0\'a0\'a0\'a0Random [
\f3 \uc0\u10004 
\f1 ]\
\'a0\'a0Pending\
BeforeEach\
AfterEach\
\'a0\'a0\'a0\'a0TODO 1 [\uc0\u8208 ]\
\'a0\'a0\'a0\'a0\'a0\'a0# PENDING: No reason given\
BeforeEach\
AfterEach\
\'a0\'a0\'a0\'a0TODO 2 [\uc0\u8208 ]\
\'a0\'a0\'a0\'a0\'a0\'a0# PENDING: TODO\
\'a0\'a0Tests with test args\
BeforeEach\
tested with=-1463817299972272612\
AfterEach\
\'a0\'a0\'a0\'a0is not zero [
\f3 \uc0\u10004 
\f1 ]\
After\
\
Finished in 0.8575 seconds\
7 examples, 0 failures, 2 pending\
\
\pard\pardeftab720\partightenfactor0

\f0 \cf2 \cb1 \
\
\
\ul Usage: bootstrapping e.g. start/stop server\ulnone \
Use 
\f2\b aroundAll
\f0\b0 \
\
e.g. start/stop server\
\pard\pardeftab720\partightenfactor0

\f1 \cf4 \cb5  \
import Control.Exception (bracket)\
aroundAll :: HasCallStack => (ActionWith a -> IO ()) -> SpecWith a -> Spec\
aroundAll_ :: HasCallStack => (IO () -> IO ()) -> SpecWith a -> SpecWith a\
\
specs :: Spec\
specs = (\\run -> do\
\'a0 bracket\
\'a0 \'a0startServer\'a0\'a0 \'a0\'a0\'a0 \'a0\'a0\'a0 \'a0\'a0\'a0 \'a0\'a0\'a0 \'a0-- step: bootstrap \'a0startServer :: IO Server\
\'a0 \'a0stopServer\'a0\'a0 \'a0\'a0\'a0 \'a0\'a0\'a0 \'a0\'a0\'a0 \'a0\'a0 \'a0 \'a0-- step: cleanup\'a0\'a0 \'a0stopServer :: Server -> IO ()\
\'a0 \'a0(const run)\'a0\'a0 \'a0\'a0\'a0 \'a0\'a0\'a0 \'a0\'a0\'a0 \'a0\'a0 \'a0\'a0-- step: run test\
\'a0) `aroundAll` baseSpecs\
\
\
baseSpecs :: Spec\
baseSpecs = describe "main" $ do\
\'a0it "should do something" $ do\'a0\
\'a0 \'85\'a0\
\
\pard\pardeftab720\partightenfactor0

\f0 \cf2 \cb1 \
e.g. start server on a different thread\
\pard\pardeftab720\partightenfactor0

\f1 \cf4 \cb5  \
import Control.Exception (bracket)\
import Control.Concurrent\
\
oneSecond = 1000 * 1000\
\
specs :: Spec\
specs = (\\run -> do\
\'a0\'a0bracket\
\'a0 \'a0(forkIO startServer <* threadDelay oneSecond) \'a0 \'a0 \'a0 \'a0 -- step: bootstrap \'a0start on a different thread \'a0startServer :: IO Server\
\'a0\'a0 \'a0\'a0\'a0 \'a0\'a0\'a0 \'a0\'a0\'a0 \'a0\'a0\'a0 \'a0\'a0\'a0 \'a0\'a0\'a0 \'a0\'a0\'a0 \'a0\'a0\'a0 \'a0\'a0\'a0 \'a0\'a0\'a0 \'a0\'a0\'a0 \'a0\'a0 \'a0 \'a0 \'a0 \'a0-- \'a0 \'a0 \'a0 Delay to wait until server is started\
\'a0\'a0\'a0killThread \'a0 \'a0 \'a0 \'a0 \'a0 \'a0 \'a0 \'a0 \'a0 \'a0 \'a0\'a0 \'a0\'a0\'a0 \'a0\'a0\'a0 \'a0\'a0\'a0 \'a0\'a0 \'a0 \'a0 \'a0-- step: cleanup \'a0 \'a0kill server thread\
\'a0\'a0\'a0(const run)\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \'a0\'a0\'a0 \'a0\'a0\'a0 \'a0\'a0\'a0 \'a0\'a0 \'a0 \'a0 \'a0-- step: run test\
 ) `aroundAll` baseSpecs\
\
\
baseSpecs :: Spec\
baseSpecs = describe "main" $ do\
 it "should do something" $ do \
\'a0\'a0\'85 \
\
\pard\pardeftab720\partightenfactor0

\f0 \cf2 \cb1 \
\
\pard\pardeftab720\partightenfactor0

\f1 \cf4 ---- Test
\f0 \cf2 \

\f1 \cf4 it\'a0"test" $ do\'a0\'85\'a0\'a0\'a0 \'a0\'a0\'a0 \'a0\'a0\'a0 \'a0\'a0\'a0 \'a0\'a0 \'a0 \'a0-- Spec\'a0
\f0 \cf2 \

\f1 \cf4 it\'a0"test" $ \\s -> do\'a0\'85\'a0\'a0\'a0 \'a0\'a0\'a0 \'a0\'a0\'a0 \'a0\'a0\'a0\'a0-- Spec String
\f0 \cf2 \

\f1 \cf4 fit\'a0"test" $ do\'a0\'85\'a0\'a0\'a0 \'a0\'a0\'a0 \'a0\'a0\'a0 \'a0\'a0\'a0 \'a0\'a0 \'a0\'a0-- focus i.e. only run this test
\f0 \cf2 \

\f1 \cf4 focus $ it\'a0"test" $ do\'a0\'85\'a0\'a0\'a0 \'a0\'a0\'a0 \'a0\'a0 \'a0 \'a0-- same
\f0 \cf2 \

\f1 \cf4 xit\'a0"test" $ do\'a0\'85\'a0\'a0\'a0 \'a0\'a0\'a0 \'a0\'a0\'a0 \'a0\'a0 \'a0 \'a0 \'a0\'a0-- ignore
\f0 \cf2 \
\

\f1 \cf4 -- Arguments
\f0 \cf2 \

\f1 \cf4 describe :: SpecWith a
\f0 \cf2 \

\f1 \cf4 describe\'a0"main" $ do\'a0\'a0 \'a0\'a0\'a0 \'a0\'a0\'a0 \'a0\'a0\'a0 \'a0\'a0 \'a0\'a0-- Change arguments\'a0\'a0 \'a0\'a0\'a0 \'a0\'a0 \'a0 \'a0\'a0
\f0 \cf2 \

\f1 \cf4 \'a0it\'a0"test" $ \\a -> do\'a0\'85\'a0\'a0\'a0\'a0 \'a0\'a0\'a0 \'a0\'a0\'a0 \'a0 \'a0 -- SpecWith a\'a0
\f0 \cf2 \

\f1 \cf4 \'a0ignoreSubject $ it\'a0"test" $ do\'a0\'85\'a0\'a0\'a0\'a0 \'a0 -- Spec
\f0 \cf2 \

\f1 \cf4 \'a0mapSubject f $ it\'a0"test" $ \\b -> do\'a0\'85 \'a0-- SpecWith b
\f0 \cf2 \
\
\

\f1 \cf4 ---- Expectation
\f0 \cf2 \

\f1 \cf4 --\'a0
\f0 \cf2 \

\f1 \cf4 1 `shouldBe` 1
\f0 \cf2 \

\f1 \cf4 1 `shouldNotBe` 1
\f0 \cf2 \

\f1 \cf4 1 `shouldSatisfy` even
\f0 \cf2 \

\f1 \cf4 io `shouldThrow` (\\(e :: IOException) -> True)
\f0 \cf2 \

\f1 \cf4 io `shouldThrow` anyException
\f0 \cf2 \
\
\
\
\pard\pardeftab720\qc\partightenfactor0
\cf2 ==============================================================\
Tasty\
\pard\pardeftab720\partightenfactor0
\cf2 \
Hackage:\'a0{\field{\*\fldinst{HYPERLINK "https://hackage.haskell.org/package/tasty-1.4.2.3#readme"}}{\fldrslt \cf3 \ul \ulc3 https://hackage.haskell.org/package/tasty-1.4.2.3#readme}}\
\cb6 \
\
Tasty\

\f1 \cb7 \
type TestName = String\
data TestTree\
\
defaultMain :: TestTree -> IO ()\
defaultMainWithIngredients :: [Ingredient] -> TestTree -> IO ()\
\pard\pardeftab720\partightenfactor0
\cf2 \cb8 testGroup :: TestName -> [TestTree] -> TestTree\
withResource :: IO a -> (a -> IO ()) -> (IO a -> TestTree) -> TestTree\cb7 \
\
defaultIngredients :: [Ingredient]\
includingOptions :: [OptionDescription] -> Ingredient\
adjustOption :: IsOption v => (v -> v) -> TestTree -> TestTree\
localOption :: IsOption v => v -> TestTree -> TestTree\
askOption :: IsOption v => (v -> TestTree) -> TestTree\
\
data Timeout = Timeout Integer String | NoTimeout\
mkTimeout :: Integer -> Timeout\
\
data DependencyType = AllSucceed | AllFinish\
after :: DependencyType -> String -> TestTree -> TestTree\
after_ :: DependencyType -> Expr -> TestTree -> TestTree\
\
\pard\pardeftab720\partightenfactor0

\f0 \cf2 \cb6 \
\
Tasty.Hspec\

\f1 \cb7 \
testSpec :: TestName -> Spec -> IO TestTree\
testSpecs :: Spec -> IO [TestTree]\
\
\cb6 \

\f0 Tasty.Hedgehog
\f1 \
\cb7 \
testProperty :: TestName -> Property -> TestTree\
testPropertyNamed :: TestName -> PropertyName -> Property -> TestTree\
fromGroup :: Group -> TestTree\
\
\cb1 \

\f0 \
\pard\pardeftab720\partightenfactor0

\f2\b \cf2 Usage
\f0\b0 : run with CLI arguments\
e.g. in stack\
\
\pard\pardeftab720\partightenfactor0

\f1 \cf2 $ stack --test-arguments "--pattern mytest" 		# run only tests containing 
\f0 \
\
\
}